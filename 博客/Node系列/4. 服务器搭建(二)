1. 跨域解决
2. 响应头设置
3. html模板ejs
4. 文件上传
5. 缓存实现

## 简单web服务器
```
const http = require('http');

const server = http.createServer((req, res) => {
    res.write("123");
    res.end();
});
server.listen(8080);

```

## 跨域
因为浏览器同源策略的原因，会对 域名，端口，协议进行校验，如果不能保证三者相同，则存在跨域拦截，即请求无法获取到服务器的返回数据

三种方式可以解决跨域
第一种. 保证前后端 域名，端口，协议 一致
第二种. 使用jsonp 解决跨域问题。
第三种. CORS，服务端设置响应头Access-Control-Allow-Origin，值为允许跨域的域名

服务端设置cors案例
```
const http = require('http');

const server = http.createServer((req, res) => {
    res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500'); // 允许跨域的域名http://127.0.0.1:5500
    res.write("123");
    res.end();
});
server.listen(8080);

```

前端ajax代码, 前端运行服务器，域名端口号为http://127.0.0.1:5500
```
const xhr = new XMLHttpRequest();
xhr.open('POST', 'http://127.0.0.1:8080/', true);
xhr.resopnseType = 'json';
// document.cookie = 'token=100';
xhr.withCredentials = true; // 跨域不允许携带cookie，设置强制携带，需要要求服务端设置的允许域名不能为*
xhr.setRequestHeader('token', 'asd.askfs.g'); // 设置请求头
xhr.onreadstatechange = function() {
    if (xhr.status === 200 && xhr.readyState === 4) {
        
    }
}
xhr.send();
```
Access-Control-Allow-Origin 响应头可设置允许域名为具体域名，也可设置为通配符 *
res.setHeader('Access-Control-Allow-Methods', 'GET,PUT,DELET,OPTIONS,POST'); // 允许的请求方式
res.setHeader('Access-Control-Allow-Headers', 'Content-type,token'); // 允许携带的请求头
res.setHeader('Access-Control-Max-age', 10); 允许权限测试的缓存时间，单位秒，options的发送间隔
res.setHeader('Access-Control-Allow-Credentials', true); // 允许跨域写到cookie
res.setHeader('Set-Cookie', ['name=1', 'age=2']); 设置cookie
res.setHeader('Content-Type', 'text/plain;charset=utf-8'); // 设置响应字符集，解决中文乱码

## ejs模板的使用
```
const ejs = require('ejs');
const fs = require('fs');
const http = require('http');

const server = http.createServer((req, res) => {
    const data = { name: 'yd', age: 18 };
    const template = fs.readFileSync(path.resolve(__dirname, 'index.ejs'), 'utf-8');
    const str = ejs.render(template, data);
    res.write(str);
    res.end();
});
server.listen(8080);
```
index.ejs;

<div>
<%=name%>  
<%=age%>
</div>

ejs 解析原理

function render(template, data) {
    return template.replace(/<%=([\s\S]*?)%>/g, function () {
        return data[arguments[1]];
    })
}

复杂一点的代码
<div>
<%arr.forEach(a => {%>
    <li><%=a%></li>
<%})%>
</div>


```
function render(template, data) {
    template = template.replace(/<%=([\s\S]*?)%>/g, function() {
        return '${' + arguments[1] + '}';
    })
    let head = 'let str;\r\nwith(data){\r\n';
    head += 'str=`';
    const content = template.replace(/<%([\s\S]*?)%>/g, function() {
        return '`\r\n' + arguments[1] + '\r\nstr+=`';
    });
    const tail = '`\r\n}\r\nreturn str;';
    const fn = new Function('data', head + content + tail);
    return fn(data);
}
```

## localStorage sessionStorage cookie 区别
localStorage: 本地存储，每个网站最大5m，一直存，不能跨域，存储在浏览器中
sessionStorage: 不关闭浏览器就存活
cookie: 浏览，每次请求时，会带上cookie，做注册登录(cookie存放不敏感信息)
session: 比较安全,内容存放在服务器，session是基于cookie
每次请求时 会自动带上cookie, 我可以去通过sssion找到当前账号的对应内容，内存存在服务器了
redis / mongo 存储到数据库中


## 附件上传
表单的三种POST提交方式 enctype
1、text/plain:  提交纯文本的数据，用的很少。
2、application/x-www-form-urlencoded：默认方式， 采用url编码方式
3、multipart/form-data: 上传文件内容，上传附件时，要选用该种类型。
如果使用x-www-form-urlencoded默认方式，也会上传文件，但只会上传文件的名字。文件内容不会上传


```
// 一个简单的服务器
const http = require('http');
const fs = reuqire('fs');
const URL = require('url');
const server = http.createServer((req, res) => {
    console.log(URL.parse(req.url, true));
    res.write("start");
    res.end();
});
server.listen(8080);
```

