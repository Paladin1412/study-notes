1. 跨域解决
2. 响应头设置
3. html模板ejs
4. 文件上传
5. 缓存实现

## 简单web服务器
```
const http = require('http');

const server = http.createServer((req, res) => {
    res.write("123");
    res.end();
});
server.listen(8080);

```

## 跨域
因为浏览器同源策略的原因，会对 域名，端口，协议进行校验，如果不能保证三者相同，则存在跨域拦截，即请求无法获取到服务器的返回数据

三种方式可以解决跨域
第一种. 保证前后端 域名，端口，协议 一致
第二种. 使用jsonp 解决跨域问题。
第三种. CORS，服务端设置响应头Access-Control-Allow-Origin，值为允许跨域的域名

服务端设置cors案例
```
const http = require('http');

const server = http.createServer((req, res) => {
    res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500'); // 允许跨域的域名http://127.0.0.1:5500
    res.write("123");
    res.end();
});
server.listen(8080);

```

前端ajax代码, 前端运行服务器，域名端口号为http://127.0.0.1:5500
```
const xhr = new XMLHttpRequest();
xhr.open('POST', 'http://127.0.0.1:8080/', true);
xhr.resopnseType = 'json';
// document.cookie = 'token=100';
xhr.withCredentials = true; // 跨域不允许携带cookie，设置强制携带，需要要求服务端设置的允许域名不能为*
xhr.setRequestHeader('token', 'asd.askfs.g'); // 设置请求头
xhr.onreadstatechange = function() {
    if (xhr.status === 200 && xhr.readyState === 4) {
        
    }
}
xhr.send();
```
Access-Control-Allow-Origin 响应头可设置允许域名为具体域名，也可设置为通配符 *
res.setHeader('Access-Control-Allow-Methods', 'GET,PUT,DELET,OPTIONS,POST'); // 允许的请求方式
res.setHeader('Access-Control-Allow-Headers', 'Content-type,token'); // 允许携带的请求头
res.setHeader('Access-Control-Max-age', 10); 允许权限测试的缓存时间，单位秒，options的发送间隔
res.setHeader('Access-Control-Allow-Credentials', true); // 允许跨域写到cookie
res.setHeader('Set-Cookie', ['name=1', 'age=2']); 设置cookie
res.setHeader('Content-Type', 'text/plain;charset=utf-8'); // 设置响应字符集，解决中文乱码

## ejs模板的使用
```
const ejs = require('ejs');
const fs = require('fs');
const http = require('http');

const server = http.createServer((req, res) => {
    const data = { name: 'yd', age: 18 };
    const template = fs.readFileSync(path.resolve(__dirname, 'index.ejs'), 'utf-8');
    const str = ejs.render(template, data);
    res.write(str);
    res.end();
});
server.listen(8080);
```
index.ejs;

<div>
<%=name%>  
<%=age%>
</div>

ejs 解析原理

function render(template, data) {
    return template.replace(/<%=([\s\S]*?)%>/g, function () {
        return data[arguments[1]];
    })
}

复杂一点的代码
<div>
<%arr.forEach(a => {%>
    <li><%=a%></li>
<%})%>
</div>


```
function render(template, data) {
    template = template.replace(/<%=([\s\S]*?)%>/g, function() {
        return '${' + arguments[1] + '}';
    })
    let head = 'let str;\r\nwith(data){\r\n';
    head += 'str=`';
    const content = template.replace(/<%([\s\S]*?)%>/g, function() {
        return '`\r\n' + arguments[1] + '\r\nstr+=`';
    });
    const tail = '`\r\n}\r\nreturn str;';
    const fn = new Function('data', head + content + tail);
    return fn(data);
}
```

## localStorage sessionStorage cookie 区别
localStorage: 本地存储，每个网站最大5m，一直存，不能跨域，存储在浏览器中
sessionStorage: 不关闭浏览器就存活
cookie: 浏览，每次请求时，会带上cookie，做注册登录(cookie存放不敏感信息)
session: 比较安全,内容存放在服务器，session是基于cookie
每次请求时 会自动带上cookie, 我可以去通过sssion找到当前账号的对应内容，内存存在服务器了
redis / mongo 存储到数据库中


## 附件上传
表单的三种POST提交方式 enctype
1、text/plain:  提交纯文本的数据，用的很少。
2、application/x-www-form-urlencoded：默认方式， 采用url编码方式
3、multipart/form-data: 上传文件内容，上传附件时，要选用该种类型。
如果使用x-www-form-urlencoded默认方式，也会上传文件，但只会上传文件的名字。文件内容不会上传


```
// 一个简单的服务器
const http = require('http');
const fs = reuqire('fs');
const URL = require('url');
const server = http.createServer((req, res) => {
    console.log(URL.parse(req.url, true));
    res.write("start");
    res.end();
});
server.listen(8080);
```

POST 提交的附件数据, 如下
```
------WebKitFormBoundarysMq8coSZNCVKkBzi
Content-Disposition: form-data; name="aaa"

12
------WebKitFormBoundarysMq8coSZNCVKkBzi
Content-Disposition: form-data; name="bbb"

13
------WebKitFormBoundarysMq8coSZNCVKkBzi
Content-Disposition: form-data; name="file"; filename="365.png"
Content-Type: image/png


------WebKitFormBoundarysMq8coSZNCVKkBzi--
```
在请求头中，存在 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysMq8coSZNCVKkBzi
boundary的值作为分隔符

```
<分隔符>
Content-Disposition: form-data; name="aaa"

12
<分隔符>
Content-Disposition: form-data; name="bbb"

13
<分隔符>
Content-Disposition: form-data; name="file"; filename="365.png"
Content-Type: image/png


<分隔符>--
```
整理数据
```
<分隔符>\r\n
Content-Disposition: form-data; name="aaa"\r\n
\r\n
12\r\n
<分隔符>\r\n
Content-Disposition: form-data; name="bbb"\r\n
\r\n
13\r\n
<分隔符>\r\n
Content-Disposition: form-data; name="file"; filename="365.png"\r\n
Content-Type: image/png\r\n
\r\n
文件内容\r\n
<分隔符>--\r\n
```

<分隔符>\r\n数据描述\r\n\r\n数据值\r\n
<分隔符>\r\n数据描述\r\n\r\n数据值\r\n
<分隔符>\r\n数据描述1\r\n数据描述2\r\n\r\n文件内容\r\n
<分隔符>--\r\n

1.用"<分隔符>"切开数据
[
  空,
  \r\n数据描述\r\n\r\n数据值\r\n,
  \r\n数据描述\r\n\r\n数据值\r\n,
  \r\n数据描述1\r\n数据描述2\r\n\r\n文件内容\r\n,
  --\r\n
]

2.丢弃头尾元素
[
  \r\n数据描述\r\n\r\n数据值\r\n,
  \r\n数据描述\r\n\r\n数据值\r\n,
  \r\n数据描述1\r\n数据描述2\r\n\r\n文件内容\r\n,
]

3.丢弃每一项的头尾\r\n
[
  数据描述\r\n\r\n数据值,
  数据描述\r\n\r\n数据值,
  数据描述1\r\n数据描述2\r\n\r\n文件内容,
]

4.用第一次出现的"\r\n\r\n"切分
  普通数据：[数据描述, 数据值]
  或
  文件数据：[数据描述1\r\n数据描述2, <文件内容>]

5.判断描述的里面有没有"\r\n"
  有的为文件数据：[数据描述1\r\n数据描述2, <文件内容>]
  没有的为普通数据：[数据描述, 数据值]

6.分析"数据描述"

用分隔符切割数据
分隔符每次都是随机的，16位字符，字母大小写加数字，共62个字符。
分隔符在请求头中，content-type的boundary, 使用分号空格将boundary切割出来。

### 对Buffer数据进行操作

```
const b = new Buffer('abcccc-=-qwerqwer');
b.indexOf('-=-');
```
1.查找    indexOf()
2.截取    slice(s, e)     [s, ..., e-1]
          slice(s)
3.切分    split
```
// 新增Buffer的split方法
Buffer.prototype.split = Buffer.prototype.split || function(b) => {
    const arr = [];
    let cur = 0;
    while ((n = this.indexOf(b, cur)) != -1) {
      arr.push(this.slice(cur, n));
      cur = n +b.length;
    }
    arr.push(this.slice(cur));
    return arr;
}
```

附件上传
```
const http = require('http');
const fs = require('fs');
const URL = require('url');
const querystring = require('querystring');

const server = http.createServer((req, res) => {
    const { pathname, methods } = URL.parse(req.url, true);
    if (req.method === 'POST') {
        res.write("成功");
        res.end();
    } else {
        fs.readFile('./index.html', (err, data) => {
            res.write(data);
            res.end();
        })
    }
});
server.listen(8080);
```


