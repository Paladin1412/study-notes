### 构造方法
自定义的Person类，成员变量，name，age
要求在new，Person的同时，就指定好name，age的值
实现功能，利用方法去实现，构造方法，构造器，Constructor
作用: 在new 的同时，对成员变量赋值，给对象的属性初始化赋值，new Person，对属性name，age赋值

构造方法的定义格式
    权限 方法名(参数列表) {

    }
    方法的名字必须和类名完全一致
    不能有返回值，void也不可以写。
```
public class Person {
    private String name;
    publc Person(String name) {
        this.name = name;
    }
}
```
实例化的时候，构造方法会自动执行，new
构造方法只执行一次，生命周期内只实现一次
构造方法不写也会默认有

一个类可以有多个构造方法，多个构造方法是以重载的形式存在的。
构造方法是可以被private修饰的，作用: 其它程序无法创建该类的对象

构造方法和一般方法的区别
1. 调用次数
2. 执行条件

this调用构造方法，
```
this(参数, 参数) // 必须写在构造方法第一行
```
顺序: main -> 创建对象 -> 无参构造 -> 有参构造 -> 赋值 -> 出栈 -> 地址引用 -> 结束

### super关键字
在子父类中构造方法的调用
可以使用super，调用父类的变量
this(),调用本类中的构造方法
super() 调用父类中的构造方法
子类可以调用父类构造器，父类无法调用子类构造器
默认添加的构造方法，public Student() {}
注意: 子类构造方法的第一行，有一个隐式代码super()
子类构造方法的报错原因，找不到父类的空参构造器
子类中没有手写构造，编译器添加默认的空参数
```
public Student() { super();}
```
编译成功，必须手动编写构造方法，请你在super中添加参数
注意: 子类中所有的构造方法，无论重载多少个，第一行必须是super()，并且每个构造方法内部都要写
如果父类有多个构造方法，子类任意调用一个就可以，而且必须是第一行

构造方法第一行，写this还是super?
不能同时存在，任选其一，保证子类的构造方法可以调用到父类构造方法，因为子类不需要调用自己，所以可以把super写在其调用的构造方法中，事实也确实是这样写的、
无论如何，子类的所有构造方法，直接，间接，必须调用到父类构造方法，子类的构造方法，什么都不写，默认的构造方法第一样super();
java中所有类的父类，object
类中的成员变量要求私有，方法不写从父类继承

###总结
this关键字，本类对象的引用
this是方法中使用的，哪个对象调用了该方法，那么this就代表调用该方法的对象引用
this什么时候存在，当创建对象的时候，this就存在
this的作用: 用来区别同名的成员变量与局部变量
构造方法: 用来给类的成员进行初始化操作

构造方法什么时候会被调用执行
只有在创建对象的时候才可以被调用
super: 指的是父类的存储空间(理解为父类的引用);
ctrl + T 打开继承关系图
super: 调用父类的成员变量
调用父类的构造方法，super();
调用父类的成员方法，super.成员方法();
继承中的构造方法注意事项:
1. 如果我们手动给出了构造方法，编译器不会在给我们提供默认的空参构造方法，如果我们没有写任何的构造方法，编译器会给我们一个空参的构造方法。
2. 在构造方法中，默认的第一条语句为super();他是用来访问父类中的空参构造方法，进行父类成员的初始化操作。
3. 当父类中没有空参构造方法的时候怎么办?
    通过super 访问父类其他有参数构造方法
    this访问本类中其他构造方法，要求其它可以访问父类
4. super(参数)与this(参数)不能同时在构造方法中存在

### final
final 的意思为最终，不可变，final是个修饰符，它可以用来修饰类，类的成员，以及局部变量
final的特点
final修饰的类不能被继承
```
public final class Fu {

}
```
点击类，按F3打开源代码
final修饰方法不可被子类重写
```
public final void show() {
}
```
final修饰的变量称为常量，只能赋值一次，且永不变
final int i = 20;
final修饰引用数据类型，变量保存的内存地址，终身不变
final修饰成员变量，成员变量在堆中有默认值
final int age; 报错，因为final修饰的成员变量，固定的不是内存的默认值，固定的是成员变量的手动赋值，绝对不是内存的默认，
成员变量: 需要在创建对象前赋值，否则报错
### static关键字
对象共享数据，static节省内存，作为共享数据存在，不再是特有内容
static注意事项
静态不能调用非静态
```
public class Student{
  String name;
  int age;
  public static void function() {
    System.out.print(name); // 错误
  }
}
```
静态不能调用非静态，因为生命周期不用导致，静态优先于非静态存在，前人播种后人收。
同一个类中，静态只能访问静态，静态中不能写this和super，this表示对象，静态先于this(先于实例化)，静态堆静态，非静态对非静态。
静态方法可以写在调用后，非静态方法从上向下执行
1. 方法写成静态
2. 先new 一个对象，用对象调用方法
静态弊端
生命周期长，浪费空间
static应用场景
static修饰成员变量，成员方法
成员变量加static，根据具体事物具体分析问题
定义事物的时候，多个事物之间是否有共性的数据，共性定义为静态，成员方法加static跟着变量走。
定义静态常量，常量名字全大写，多个词用下划线链接 XU_ZHI_FEI
接口中全都是静态常量
```
interface Inter {
  public static final int COUNT = 100;
}
```
Inter.COUNT;

### 匿名对象
匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址赋值给某个变量，new Person();
匿名对象，没有引用变量，只能使用一次，每次new的都是不同的。
匿名对象作为方法的参数，或者作为返回值。
内部类
将类写在其他类的内部，可以写在其他类的成员位置，和局部位置，这时写在其他类内部的类成为内部类，其他类称为外部类，若一个事物内部，还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含发动机，这时发动机就可以使用内部类来描述
```
class Car {
    class Engine {

    }
}
```
内部类也是类，有修饰符，可继承，可以实现接口
内部类可以使用外部类成员，包括私有，因为还在这个类中，外部类不能直接使用内部类成员，必须建立对象。
调用: 内部类是外部类的成员。
外部类名.内部类名
变量 = new 外部类对象();

引用外部类的成员变量， 外部类名.this.变量名;
局部内部类:
在一个方法中定义一个内部类，利用返回值
匿名内部类
是局部内部类的一种
定义的匿名内部类有两个含义:
临时定义某一指定类型的子类
定以后即刻创建刚刚定义的这个子类对象。
将实现类重写方法和建立对象，合为一体。
格式:
```
new 接口或者父类() {
    重写抽象方法
}

new Smoking() {
    public void smoking() {
        
    }
}
```
类都会生成class文件
匿名内部类必须满足，集成或实现接口才可以
java中的方法不能写调用
