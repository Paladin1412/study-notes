1. 先按照名词提炼问题领域中的对象
2. 对对象进行描述，其实就是在明确对象中应该具备的属性和功能
3. 通过new的方式就可以创建该事物的具体对象
4. 通过该对象调用它以后的功能

包就是文件夹
new -> package -> 填写包名(国家.域名.名称)
新建cn.feiyang.test的包 -> 新建类 -> 不需要main方法
```
public class Car {
    String color;
    int count;
    public void run() {
        System.out.print("小汽车在跑: " + color);
    }
}

public class CarTest {
    public static void main(String[] args) {
        Car c = new Car();
        c.color = "无色";
    }
}
```

局部变量和成员变量的区别
- 定义的位置不同
成员变量定义在类中
局部变量定义在方法或者{}内
- 在内存中的位置不同
成员变量在堆的中
局部变量存储在栈中
- 生命周期不同
成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失
局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失
- 初始化不同
成员变量因为在堆内存中，所以默认的初始化值
局部变量没有默认的初始化值，必须手动的给其赋值才可以使用

### 封装
方法就是一个最基本封装体
类其实也是一个封装体
1. 提高了代码的复用性
2. 隐藏了实现细节，还要对外提供可以访问的方式，便于调用者的使用，这是核心之一，也可以理解为就是封装的概念
3. 提高了安全性

### private 关键字
私有，属于成员修饰符，不能修饰局部变量
对私有变量，提供公共的访问方式，通过方法去访问
```
public class Person {
    private age;
    public void setAge(int age) {
        age = age;
    }
    public int getAge() {
        return age;
    }
}
```

### this关键字
区分成员变量和局部变量的重名问题

### 继承
子类继承父类的属性和方法
使用extends关键字
1. 继承的出现提高了代码的复用性，提高软件开发效率
2. 继承的出现让类与类之间产生了关系，提供了多态的前提

java中，类只支持单继承，不允许多继承，也就是一个类只能有一个父类，不能有多个父类
this. 滴啊用自己的本类成员
super. 调用自己的父类成员

子类中，出现了和父类一模一样的方法的时候，子类重写父类的方法，子类中会覆盖父类的方法。
重写父类方法的时候，最好在子类中通过super.方法名调用一下父类方法，保留父类方法功能
重写方法注意，子类方法的权限要大于等于父类方法的权限
public > protected -> default -> private
default权限是默认权限，如果使用改权限，不能写改关键字，写了就会报错
返回值，方法名，参数列表要保证一模一样

### 抽象
父类知道子类包含哪些方法和哪些变量，父类不知道如何实现，父类就要抽象
抽象的方法不允许有主体，也就是不能有大括号
抽象的方法存在于一个抽象的类中 abstract
```
public abstract class Develop {
    // 必须使用abstract关键字修饰
    public abstract void work();
}
```
抽象类不能实例化对象，也就是不能使用new调用
可以使用类，继承抽象类，将抽象方法重写。创建子类对象
抽象关键字不能和private共同使用，private修饰的方法是不能被继承得到的，也就没办法重写
```
public class JavaEE extends Develop {
    public void work() {
        System.out.print("继承类");
    }
}
```

抽象类的特点。
1. 抽象类和抽象方法都需要被abstract修饰，抽象方法一定要定义在抽象类之中
2. 抽象类不可以直接创建对象，原因是抽象方法没有意义
3. 只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象，否则改子类还是一个抽象类

自动生成get和set方法
右键 -> source -> generate getters and setters -> select all -> ok;

### 接口
接口是功能的集合，同样可看做是一种数据类型，是比抽象类更抽象的类
接口只描述所应具备的方法，并没有具体实现。
```
public interface Test {
    public abstract void function();
}
```
接口定义
    成员方法，全抽象
    不能定义带有方法体的方法
定义抽象方法: 固定格式
    public abstract 返回值类型 方法名(参数列表);
    修饰符 public 写或者不写，都是public
接口成员变量
    成员变量必须定义为常量，永远不可以改变
    public static final int a = 1;

接口的实现
implements

接口实现可以实现无数个
```
// instanceof 判断对象是否是类的实例
person p = new Person();
p instanceof Person;
```
接口的特点:
1. 定义一个接口用interface关键字
    public interface Inter {}
2. 一个类实现一个接口，实现implements 关键字
    class Demo implements Inter {}
3. 接口不能直接创建对象
    通过多态的方式，由子类来创建对象，接口多态
接口成员的特点
1. 成员变量
    只能是final修饰的常量
    默认修饰符：public static final
    public 权限
    static 可以直接通过类名调用
    final 最终值，固定值
2. 构造方法
3. 成员方法
    只能是抽象方法
    默认修饰符 public abstract
    重写接口中的抽象方法，public权限是必须的
4. 实现类和实现方法
    实现类，实现接口，重写接口全部抽象方法，创建实现类对象
    实现类，重写了一部分抽象方法，实现类，还是一个抽象类

类继承类的同事，可以实现多个接口
```
public class C extends D implements A, B {

}
```
接口中权限只能是public
接口是一种暴露出来的规则

接口和抽象类的区别

犬
    行为
        吼叫
        吃饭
缉毒犬
    行为
        吼叫
        吃饭
        缉毒
通用的东西是出现，额外的东西是接口
继承抽象，实现接口

优先选用接口，尽量少用抽象类
需要定义子类的行为，又要为子类提供共性功能时采选用抽象类

### 多态
多态：理解为同一种特质的多重状态
```
Person p = new Student();
```
多态使用的前提
    1. 有继承或者实现关系
    2. 要方法重写
    3. 父类引用指向子类对象。
成员变量的特点
    编译的时候，参考父类中有没有这个变量，如果有，编译成功，否则编译失败
    运行的时候，运行的是父类中的变量值。
成员的方法特点
    编译的时候，参考父类中有没有这个方法，如果有，编译成功，否则编译失败
    运行的时候，运行的是子类中的方法。
多态的成员访问特点
    方法的运行看右边，其它看左边
多态的好处
    提高了程序的扩展性
多态的弊端
    不能访问子类的特有功能
多态的分类
    类的多态