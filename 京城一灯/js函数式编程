## javascript functional programming

### 一. 函数式编程思维
范畴论 Category Theory
1. 函数式编程是范畴论的数学分支，是一门很复杂的数学，认为世界上所有概念体系都可以抽象出一个个范畴。
2. 彼此之间存在某种关系概念，事物，对象等等，都构成范畴。任何事物只要找出他们之间的关系，就能定义。
3. 箭头表示范畴成员之间的关系，正式的名称叫做态射，范畴论认为，同一个范畴的所有成员，就是不同状态的变形，通过态射，一个成员可以变形成另一个成员。

所有成员是一个集合，变形关系是函数

函数式编程基础理论
1. 函数式编程 其实相对于计算机的历史而言是一个非常古老的概念，设置早于第一台计算机的诞生。函数式编程的基础模型来源于λ演算，而λ演算并非设计于在计算机上执行，他是在20世纪三十年代引入的一套用于研究函数定义，函数应用和递归的形式系统。
2. 函数式编程不是用函数来编程，也不是传统的面向过程编程，主旨在于将复杂的函数复合成简单的函数(计算理论，或者递归论，或者拉姆达运算)，运算过程尽量写成一系列嵌套的函数调用
3. javascript 是披着C外衣的lisp
java c# php js 都是类c语言，就是从c语言演化过来的，copy到c语言中，可以直接运行。
4. 真正的火热是随着React的高阶函数而逐步升温。

用函数编程和函数式编程，借助一些数学的方式，使用js的语法进行开发。
区别: 
用函数式编程的时候，不能写if和else，因为数学中没有if和else，也没有while，就是用数学的思维，使用js语法承接，可以用递归，因为数学有递归。

js中的公民
1. 函数是一等公民，所以一等公民first class，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。
2. 不可变变量，在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了，在函数式编程中，变量仅仅代表某个表达式。这里所说的变量是不能被修改的，所有的变量只能被赋一次初始值。
3. map & reduce他们是最常用的函数式编程的方法。

函数式第一等公民，
只用表达式，不用语句，
没有副作用，
不修改状态，
引用透明(函数运行只靠参数)。

### 二. 函数式编程常用核心概念
- 纯函数
如果做函数式变成，函数一定要纯。
1. 对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。
```
var xs = [1, 2, 3 ,4 ,5];
// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的。
// 下面这个会让变量衰减，所以不是纯函数。
xs.slice(0, 3);
sx.slice(0, 3);
```
lodash是一个纯函数式编程的库
```
import _ from 'lodash';
var sin = _.memorize(x => Math.sin(x));
// 第一次计算的时候会稍慢一点。
var a = sin(7);
// 第二次有了缓存速度极快
var b = sin(7);
```
纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，比如可缓存性。

```
// 不纯的
var min = 18;
var checkage = age => age > min;
// 纯的，这很函数式
var checkage age => age > 18;
```
在不纯的版本中，checkage不仅取决于age还有外部依赖的变量min
纯的checkage把关键数组18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。

- 函数的柯里化
传递给函数一部分参数来调用它，让他返回一个函数去处理剩下的参数
我们一起来用柯里化来改变他
```
var checkage = min => (age => age > min);
var checkage18 = checkage(18);

checkage18(20);
```
函数的柯里化code
```
// 柯里化之前
function add(x, y) {
    return x + y;
}
add(1, 2) // 3;

// 柯里化之后
function addX(y) {
    return function(x) {
        return x + y;
    }
}
addX(2)(1); // 3
```
柯里化目的，不让纯函数硬编码，也不让函数和外部有太多依赖。

使用bind实现柯里化
```
function foo(p1, p2) {
    this.val = p1 + p2;
}
var bar = foo.bind(null, 'p1');
var baz = new bar('p2');
console.log(baz.val);
```
上面bind是一个经典的柯里化，

柯里化的优缺点
```
import { curry } from 'lodash';
var match = curry((req, str) => str.match(reg));
var filter = curry((f, arr) => arr.filter(f));
var havaSpace = match(/\s+/g);
// haveSpace('ffffff');
// haveSpace('a b');
// filter(haveSpace, ['abcdefg', 'hello world']);
filter(haveSpace)(['abcdefg'], 'hello world');
```
事实上柯里化是一种预加载函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的缓存，是一种非常搞笑的编写函数的方法:

- 函数组合
- Point Free
- 声明式与命令式代码
- 惰性求值


### 三. 当下函数式编程最热的库
### 四. 函数式编程的实际应用场景