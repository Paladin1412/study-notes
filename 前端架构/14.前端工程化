### webpack
webpack-cli 工具
npx 是webpack带的命令工具，使用npx运行webpack会使用项目node_module中的webpack
```
npx webpack -v
npx webpack index.js // 打包
```
webpack 默认只认识js模块，而且只支持模块语法。
如果用require引入，要用module.exports = a;
如果用import 引入，可以使用 default export a;

npm info webpack; // 查看webpack历史版本
npm install webpack@4.12.0 --D; // -D === --save-dev

loader顺序，从右到左，从下到上;
postcss-loader: 添加兼容版本
css-loader: 把多个css整合
style-loader: 把css挂在html上

sourceMap：源代码与打包后代码的映射关系，不同的设置值会影响配置

devServer：服务器
devServer: {
    contentBase: "./dist",
    open: true, // 自动打开浏览器
    proxy: { // 代理
        '/api': {
            target: 'http://localhost'
        }
    },
    hot: true, // 开启html热替换 hmr
    hotOnly: true // 不刷新浏览器
}
hmr 热替换，需要在plugins中引入
plugins: [
    new webpack.HotModuleReplacementPlugin()
]
需要使用style-loader, 不能使用mini提取css

js的hmr, 使用module.hot
```
if (module.hot) {
    module.hot.accept('./number', () => {
        console.log('变化了');
    })
}
```

babel：
```
loader: "babel-loader",
options: {
    presets: [
        "@babel/preset-env",
        {
            targets: {
                edge: "17",
                firefox: "60",
                chrome: "67",
                "safari": "11.1"
            },
            useBuiltInt: "useage", // 按需注入
        }
    ]
}
```

polyfill, 会把js注入到全局变量中，污染全局，适合在项目中，不适合在插件和工具库中使用
plugin-transform-runtime: 闭包的注入方式，不会影响全局，适合工具库
```
npm i @babel/plugin-transform-runtime --save;
npm i @babel/runtime --save;

loader: "babel-loader",
options: {
   plugin: ["@babel/plugin-transform-runtime", {
       corejs: 
   }]
}

```

### Loader编写
官网loaders中存放loader的api
```
npm init -y;
npm install webpack webpack-cli -D;
```
webpack 配置
```
const path = require('path');
module.exports = {
    mode: "development",
    entry: "./index.js",
    module: {
        rules: {
            test: /\.js$/,
            use: path.resolve(__dirname, "./loaders/replaceLoader.js")
        }
    },
    output: {
        path: path.resolve(__dirname, "dist")
    }
}
```

replaceLoader.js
```
module.exports = function(source) { // 不能用剪头函数，否则拿不到上下文的this
    console.log(this, source); // 输出的就是entry中的js的源码
    return source.replace(/aaa/, 'bbb');
}
```
插件接收的参数:

```
module.exports = function(source) {
    console.log(this.query); // 为传入的参数
    return source;
}
```

loader-utils; 官方推荐处理loader.query的工具
```
const loaderUtils = require('loader-utils');
module.exports = function(source) {
    const options = loaderUtils.getOptions(this);
    console.log(options);
    return source;
}
```

this.callback：返回更多内容, 替代return

```
module.exports = function(source) {
    const options = loaderUtils.getOptions(this);
    const result = "2123";
    this.callback(null, result);
}
```

this.async: 处理异步
```
module.exports = function(source) {
    const options = loaderUtils.getOptions(this);
    // 定义异步callback
    const callback = this.async();
    setTimeout(() => {
        const result = "2123";
        callback(null, result);
    });
}
```

resolveLoader: webpack配置loader简写

```
resolveLoader: {
    modules: ["node_modules", "./loaders"], // 当配置文件里面使用模块，先去node_modules里面找，如果找不到就去后面路径上面找
}
```

### Plugins编写
plugin开始打包，在某个时候，帮助我们吃力一些什么事情的机制
pubgin要比loader稍微复杂一些，在webpack的源码中，用plugin的机制还是占有非常大的场景，可以说plugin是webpack的灵魂
设计模式:
- 事件驱动
- 发布订阅
plugin是一个类，里面包含一个apply函数，接受一个参数，compiler

代码如下
```
class CopyRightWebpackPlugin {
    constructor(options) {
        console.log(options);
    }
    apply(compiler) {
        // console.log(compiler);
        compiler.hooks.emit.tapAsync('CopyRightWebpackPlugin', (complilation, cb) => {
            // assets 资源文件
            complilation.assets["copyright.txt"] = {
                source: function() { // 文件内容
                    return "hello copyright";
                },
                size: function() { // 文件大小
                    return 30;
                }
            };
            cb();
        });
        compiler.hooks.compile.tab('CopyRightWebpackPlugin', (complilation) => {
            console.log("同步方法");
        })
    }
}
module.exports = CopyRightWebpackPlugin;
```
hooks
生命周期
- emit
异步方法，接收两个参数，第一个参数是类名字符串，第二个参数是个回调，回调中接收两个参数

### node调试工具
```
"script": {
    "debug": "node --inspect --inspect-brk node_modules/webpack/bin/webpack.js"
}
```

### webpack 打包原理分析

```bundile.js

const fs = require('fs');
const fenximokuai = function(entry) { // 接收一个入口文件
    const content = fs.readFileSync(entry, 'utf-8');
    console.log(content);
}

fenximokuai("./src/index.js");

```