http是一种无状态的协议，如何确定当前请求人的身份，需要用到鉴权

### 鉴权方式
- session/cookie
传统方式，会话机制
- token
前后端分离，token方式
- oauth
开放方式，open author

### session/cookie 验证
1. 服务器在接收客户端首次访问时，在服务器创建session，然后保存session，可以将session存在内存中，也可以保存在redis中，推荐后者。然后给这个session生成一个唯一的标识字符串，在响应头中种下这个唯一标识字符串。
2. 签名，这一步通过密钥对sid进行签名处理，避免客户端修改sid(非必须步骤)
3. 浏览器中收到请求响应的二十户会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求头中会带上该域名下的cookie信息
4. 服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后进行判断请求是否合法。

### token验证
1. 登录成功，服务器生成一个令牌，可以通过jwt，返回给浏览器
2. 浏览器取到cookie, 存在cookie中，再次发送请求时，检验token是否合法
3. 从token中解析用户信息
4. 建议使用加密后的密码来做签名，确保每个人都不一样
优点
服务端更加轻便可以实现很多可能

缺点：
不安全，任何人拿到令牌都可以通过验证
数据一般通过base64编码的，所以不是很安全，因此不要存入敏感信息，密码之类的

```
const jwt = require('jsonwebtoken');
const jwtAuth = require('koa-jwt');
const secret = "it‘s a secret";

const token = jwt.sign(
    {
    data: userInfo,
    exp: Math.floor(Date.now() / 1000) + 60 * 60 // 失效时间1小时
    },
    secret
)

```

jwt签名原理:
签名只是防篡改
HMAC SHA256(散列反篡改)
因为前端不知道服务器的secret，所以没办法准确的修改token，任何的改动都是不合法的，所以可以有效防止篡改
中间的数据部分，使用的是base64编码，他可以反解出来，因此不能存放敏感信息
Beare 是一种认证类型，(基于Oauth2.0), 使用 Bearer关键词进行定义

### Oauth
开放授权
三方登入主要基于OAuth2.0，OAuth协议为用户资源的授权提供了一个安全的，开放而又简易的标准。与以往的授权方式不同之处是OAuh的授权不会使第三方触及到用户的账号信息(如用户名和密码)，即第三方无需使用用户的用户名和密码就可以申请获得该用户资源的授权，因此OAuth是安全的。
